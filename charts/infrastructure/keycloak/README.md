# Keycloak

Keycloak Identity and Access Management using the official Keycloak Operator.

## Prerequisites

- Postgres Operator installed
- Keycloak Database deployed
- cert-manager installed (for TLS certificates)
- ingress-nginx installed

## Installation

```bash
./scripts/deploy-gke.sh keycloak
```

## Access

After deployment, access Keycloak at:
- **URL:** `https://keycloak.<INGRESS_IP>.nip.io`
- **Admin User:** `admin`
- **Admin Password:** Set during deployment (default: `admin`)

## Architecture

This chart deploys Keycloak using a **two-phase approach**:

### Phase 1: Operator + CRDs
- Deploys the Keycloak Operator
- Registers Keycloak CRDs
- Operator manages Keycloak instances

### Phase 2: Keycloak Instance
- Creates Keycloak custom resource
- Deploys Keycloak pods
- Connects to PostgreSQL database

### Ingress Management

**Important:** The Ingress is managed by **Helm**, not the Keycloak Operator.

- Operator's Ingress creation is **disabled** (`ingress.enabled: false` in Keycloak CR)
- Helm creates the Ingress with proper TLS configuration
- cert-manager automatically issues Let's Encrypt certificates
- This approach ensures:
  - Proper TLS secret configuration
  - Helm ownership of all resources
  - No conflicts between operator and Helm
  - Repeatable deployments from scratch

### TLS Certificate

- Managed by cert-manager via a separate `Certificate` resource
- Uses Let's Encrypt production issuer
- Automatically renewed before expiration

## Configuration

### Admin Password

Set via environment variable:

```bash
export KEYCLOAK_ADMIN_PASSWORD="your-secure-password"
./scripts/deploy-gke.sh keycloak
```

### Database

Automatically connects to PostgreSQL database created by `keycloak-db` chart using the secret generated by Postgres Operator.

### Hostname

The hostname is automatically set based on the Terraform output:

```bash
keycloak.<INGRESS_IP>.nip.io
```

## Verification

```bash
# Check operator
kubectl get pods -n keycloak -l app.kubernetes.io/name=keycloak-operator

# Check Keycloak instance
kubectl get keycloak -n keycloak

# Check pods
kubectl get pods -n keycloak -l app=keycloak

# Check ingress (managed by Helm)
kubectl get ingress -n keycloak

# Check certificate
kubectl get certificate -n keycloak

# Check Keycloak status
kubectl get keycloak keycloak -n keycloak -o jsonpath='{.status.conditions}' | jq .
```

## Troubleshooting

### Ingress Conflicts

If you see errors about Ingress ownership or conflicts:

1. Delete the operator-created Ingress:
   ```bash
   kubectl delete ingress keycloak-ingress -n keycloak
   ```

2. Restart the operator to clear error state:
   ```bash
   kubectl rollout restart deployment/keycloak-operator -n keycloak
   ```

3. Redeploy with Helm:
   ```bash
   ./scripts/deploy-gke.sh keycloak
   ```

### Certificate Issues

If the certificate is not being created:

1. Check cert-manager logs:
   ```bash
   kubectl logs -n cert-manager deployment/cert-manager
   ```

2. Check certificate status:
   ```bash
   kubectl describe certificate keycloak-tls -n keycloak
   ```

3. Verify ClusterIssuer exists:
   ```bash
   kubectl get clusterissuer letsencrypt-prod
   ```

## ArgoCD Compatibility

Fully compatible with ArgoCD:
- Uses official Keycloak Operator (OCI registry)
- Declarative Keycloak CR
- External database via existing secret
- Helm-managed Ingress with proper annotations
- Separate Certificate resource for TLS
